{
    "docs": [
        {
            "location": "/",
            "text": "Triage\n\n\nRisk modeling and prediction\n\n\n\n\n\n\n\n\nPredictive analytics projects require the coordination of many different tasks, such as feature generation, classifier training, evaluation, and list generation. These tasks are complicated in their own right, but in addition have to be combined in different ways throughout the course of the project. \n\n\nTriage aims to provide interfaces to these different phases of a project, such as an \nExperiment\n. Each phase is defined by configuration specific to the needs of the project, and an arrangement of core data science components that work together to produce the output of that phase.\n\n\nExperiment\n\n\nThe first phase implemented in triage is the \nExperiment\n. An experiment represents the initial research work of creating design matrices from source data, and training/testing/evaluating a model grid on those matrices. At the end of the experiment, a relational database with results metadata is populated, allowing for evaluation by the researcher.\n\n\nPrerequisites\n\n\nTo use a Triage experiment, you first need:\n\n\n\n\nPython 3+\n\n\nA PostgreSQL database with your source data (events, geographical data, etc) loaded.\n\n\nAmple space on an available disk (or S3) to store the needed matrices and models for your experiment\n\n\n\n\nExperiment Run Example\n\n\nThe basic execution of an experiment looks something like the following:\n\n\n    SingleThreadedExperiment(\n        config=experiment_config,\n        db_engine=sqlalchemy.create_engine(...),\n        model_storage_class=FSModelStorageEngine,\n        project_path='/path/to/directory/to/save/data'\n    ).run()\n\n\n\n\nThese lines are a bit dense: what is happening here?\n\n\n\n\nSingleThreadedExperiment\n:  There are different Experiment classes available in \ntriage.experiments\n to use, and they each represent a different way of executing the experiment, which we'll talk about in more detail later. The simplest (but slowest) is the SingleThreadedExperiment.\n\n\nconfig=experiment_config\n: The bulk of the work needed in designing an experiment will be in creating this experiment configuration. An up-to-date example is at \nexample_experiment_config.yaml\n; more detailed instructions on each section are located in the example file. Generally these would be easiest to store as a file (or multiple files that you construct together) like that YAML file, but the configuration is passed in dict format to the Experiment constructor and you can store it however you wish.\n\n\ndb_engine=sqlalchemy.create_engine(...)\n: A SQLAlchemy database engine. This will be used both for querying your source tables and writing results metadata.\n\n\nmodel_storage_class=FSModelStorageEngine\n: The path to a model storage engine class. The library that triage uses for model training and evaluation, \ncatwalk\n, provides multiple classes that handle storing trained models in different mediums, such as on the local filesystem or Amazon S3. We recommend starting with the \ncatwalk.storage.FSModelStorageEngine\n to save models on the local filesystem.\n\n\nproject_path='/path/to/directory/to/save/data'\n: The path to where you would like to store design matrices and trained models.\n\n\n\n\nWith that in mind, a more full version of the experiment run script might look like this:\n\n\nimport sqlalchemy\nimport yaml\n\nfrom catwalk.storage import FSModelStorageEngine\nfrom triage.experiments import SingleThreadedExperiment\n\nwith open('my_experiment_config.yaml') as f:\n    experiment_config = yaml.load(f)\nwith open('my_database_creds') as f:\n    db_connection_string = yaml.load(f)['db_connection_string']\n\nexperiment = SingleThreadedExperiment(\n    config=experiment_config,\n    db_engine=sqlalchemy.create_engine(db_connection_string),\n    model_storage_class=FSModelStorageEngine,\n    project_path='/home/research/myproject'\n)\n\nexperiment.run()\n\n\n\n\nEvaluating results of an Experiment\n\n\nAfter the experiment run, a results schema will be created and populated in the configured database with the following tables:\n\n\n\n\nexperiments - The experiment configuration and a hash\n\n\nmodels - A model describes a trained classifier; you'll have one row for each trained file that gets saved.\n\n\nmodel_groups - A model groups refers to all models that share parameters like classifier type, hyperparameters, etc, but \nhave different training windows\n. Look at these to see how classifiers perform over different training windows.\n\n\nfeature_importances - The sklearn feature importances results for each trained model\n\n\npredictions - Prediction probabilities for entities generated against trained models\n\n\nevaluations - Metric scores of trained models over given testing windows\n\n\n\n\nHere's an example query, which returns the top 10 model groups by precision at the top 100 entities:\n\n\nselect\n    model_groups.model_group_id,\n    model_groups.model_type,\n    model_groups.model_parameters,\n    max(evaluations.value) as max_precision\nfrom model_groups\n    join models using (model_group_id)\n    join evaluations using (model_id)\nwhere\n    metric = 'precision@'\n    and parameter = '100_abs'\ngroup by 1,2,3\norder by 4 desc\nlimit 10\n\n\n\n\nThe resulting schema is also readable by \nTyra\n, our model evaluation webapp.\n\n\nRestarting an Experiment\n\n\nIf an experiment fails for any reason, you can restart it. Each matrix and each model file is saved with a filename matching a hash of its unique attributes, so when the experiment is rerun, it will by default reuse the matrix or model instead of rebuilding it. If you would like to change this behavior and replace existing versions of matrices and models, set \nreplace=True\n in the Experiment constructor.\n\n\nInspecting an Experiment before running\n\n\nBefore you run an experiment, you can inspect properties of the Experiment object to ensure that it is configured in the way you want. Some examples:\n\n\n\n\nexperiment.all_as_of_times\n for debugging temporal config. This will show all dates that features and labels will be calculated at.\n\n\nexperiment.feature_dicts\n will output a list of feature dictionaries, representing the feature tables and columns configured in this experiment\n\n\nexperiment.matrix_build_tasks\n will output a list representing each matrix that will be built.\n\n\n\n\nExperiment Classes\n\n\n\n\nSingleThreadedExperiment\n: An experiment that performs all tasks serially in a single thread. Good for simple use on small datasets, or for understanding the general flow of data through a pipeline.\n\n\nMultiCoreExperiment\n: An experiment that makes use of the multiprocessing library to parallelize various time-consuming steps. Takes an \nn_processes\n keyword argument to control how many workers to use.\n\n\n\n\nBackground\n\n\nTriage is developed at the University of Chicago's \nCenter For Data Science and Public Policy\n. We created it in response to commonly occuring challenges we've encountered and patterns we've developed while working on projects for our partners.\n\n\nMajor Components Used by Triage\n\n\nTriage makes use of many core data science components developed at DSaPP. These components can be useful in their own right, and are worth checking out if \n\n\n\n\nArchitect\n: Plan, design and build train and test matrices. Includes feature and label generation.\n\n\nCollate\n: Aggregation SQL Query Builder. This is used by the Architect to build features.\n\n\nTimechop\n: Generate temporal cross-validation time windows for matrix creation\n\n\nMetta-Data\n: Train and test matrix storage\n\n\nCatwalk\n: Training, testing, and evaluating machine learning classifier models\n\n\nResults Schema\n: Generate a database schema suitable for storing the results of modeling runs\n\n\n\n\nDesign Goals\n\n\nThere are two overarching design goals for Triage:\n\n\n\n\n\n\nAll configuration necessary to run the full experiment from the external interface (ie, Experiment subclasses) from beginning to end must be easily serializable and machine-constructable, to allow the eventual development of tools for users to design experiments. \n\n\n\n\n\n\nAll core functionality must be usable outside of a specific pipeline context or workflow manager. There are many good workflow managers; everybody has their favorite, and core functionality should not be designed to work with specific execution expectations.\n\n\n\n\n\n\nFuture Plans\n\n\n\n\nGeneration and Management of lists (ie for inspections) by various criteria\n\n\nIntegration of components with various workflow managers, like \nDrain\n and \nLuigi\n.\n\n\nComprehensive leakage testing of an experiment's modeling run\n\n\nFeature Generation Wizard",
            "title": "Home"
        },
        {
            "location": "/#triage",
            "text": "Risk modeling and prediction     Predictive analytics projects require the coordination of many different tasks, such as feature generation, classifier training, evaluation, and list generation. These tasks are complicated in their own right, but in addition have to be combined in different ways throughout the course of the project.   Triage aims to provide interfaces to these different phases of a project, such as an  Experiment . Each phase is defined by configuration specific to the needs of the project, and an arrangement of core data science components that work together to produce the output of that phase.",
            "title": "Triage"
        },
        {
            "location": "/#experiment",
            "text": "The first phase implemented in triage is the  Experiment . An experiment represents the initial research work of creating design matrices from source data, and training/testing/evaluating a model grid on those matrices. At the end of the experiment, a relational database with results metadata is populated, allowing for evaluation by the researcher.",
            "title": "Experiment"
        },
        {
            "location": "/#prerequisites",
            "text": "To use a Triage experiment, you first need:   Python 3+  A PostgreSQL database with your source data (events, geographical data, etc) loaded.  Ample space on an available disk (or S3) to store the needed matrices and models for your experiment",
            "title": "Prerequisites"
        },
        {
            "location": "/#experiment-run-example",
            "text": "The basic execution of an experiment looks something like the following:      SingleThreadedExperiment(\n        config=experiment_config,\n        db_engine=sqlalchemy.create_engine(...),\n        model_storage_class=FSModelStorageEngine,\n        project_path='/path/to/directory/to/save/data'\n    ).run()  These lines are a bit dense: what is happening here?   SingleThreadedExperiment :  There are different Experiment classes available in  triage.experiments  to use, and they each represent a different way of executing the experiment, which we'll talk about in more detail later. The simplest (but slowest) is the SingleThreadedExperiment.  config=experiment_config : The bulk of the work needed in designing an experiment will be in creating this experiment configuration. An up-to-date example is at  example_experiment_config.yaml ; more detailed instructions on each section are located in the example file. Generally these would be easiest to store as a file (or multiple files that you construct together) like that YAML file, but the configuration is passed in dict format to the Experiment constructor and you can store it however you wish.  db_engine=sqlalchemy.create_engine(...) : A SQLAlchemy database engine. This will be used both for querying your source tables and writing results metadata.  model_storage_class=FSModelStorageEngine : The path to a model storage engine class. The library that triage uses for model training and evaluation,  catwalk , provides multiple classes that handle storing trained models in different mediums, such as on the local filesystem or Amazon S3. We recommend starting with the  catwalk.storage.FSModelStorageEngine  to save models on the local filesystem.  project_path='/path/to/directory/to/save/data' : The path to where you would like to store design matrices and trained models.   With that in mind, a more full version of the experiment run script might look like this:  import sqlalchemy\nimport yaml\n\nfrom catwalk.storage import FSModelStorageEngine\nfrom triage.experiments import SingleThreadedExperiment\n\nwith open('my_experiment_config.yaml') as f:\n    experiment_config = yaml.load(f)\nwith open('my_database_creds') as f:\n    db_connection_string = yaml.load(f)['db_connection_string']\n\nexperiment = SingleThreadedExperiment(\n    config=experiment_config,\n    db_engine=sqlalchemy.create_engine(db_connection_string),\n    model_storage_class=FSModelStorageEngine,\n    project_path='/home/research/myproject'\n)\n\nexperiment.run()",
            "title": "Experiment Run Example"
        },
        {
            "location": "/#evaluating-results-of-an-experiment",
            "text": "After the experiment run, a results schema will be created and populated in the configured database with the following tables:   experiments - The experiment configuration and a hash  models - A model describes a trained classifier; you'll have one row for each trained file that gets saved.  model_groups - A model groups refers to all models that share parameters like classifier type, hyperparameters, etc, but  have different training windows . Look at these to see how classifiers perform over different training windows.  feature_importances - The sklearn feature importances results for each trained model  predictions - Prediction probabilities for entities generated against trained models  evaluations - Metric scores of trained models over given testing windows   Here's an example query, which returns the top 10 model groups by precision at the top 100 entities:  select\n    model_groups.model_group_id,\n    model_groups.model_type,\n    model_groups.model_parameters,\n    max(evaluations.value) as max_precision\nfrom model_groups\n    join models using (model_group_id)\n    join evaluations using (model_id)\nwhere\n    metric = 'precision@'\n    and parameter = '100_abs'\ngroup by 1,2,3\norder by 4 desc\nlimit 10  The resulting schema is also readable by  Tyra , our model evaluation webapp.",
            "title": "Evaluating results of an Experiment"
        },
        {
            "location": "/#restarting-an-experiment",
            "text": "If an experiment fails for any reason, you can restart it. Each matrix and each model file is saved with a filename matching a hash of its unique attributes, so when the experiment is rerun, it will by default reuse the matrix or model instead of rebuilding it. If you would like to change this behavior and replace existing versions of matrices and models, set  replace=True  in the Experiment constructor.",
            "title": "Restarting an Experiment"
        },
        {
            "location": "/#inspecting-an-experiment-before-running",
            "text": "Before you run an experiment, you can inspect properties of the Experiment object to ensure that it is configured in the way you want. Some examples:   experiment.all_as_of_times  for debugging temporal config. This will show all dates that features and labels will be calculated at.  experiment.feature_dicts  will output a list of feature dictionaries, representing the feature tables and columns configured in this experiment  experiment.matrix_build_tasks  will output a list representing each matrix that will be built.",
            "title": "Inspecting an Experiment before running"
        },
        {
            "location": "/#experiment-classes",
            "text": "SingleThreadedExperiment : An experiment that performs all tasks serially in a single thread. Good for simple use on small datasets, or for understanding the general flow of data through a pipeline.  MultiCoreExperiment : An experiment that makes use of the multiprocessing library to parallelize various time-consuming steps. Takes an  n_processes  keyword argument to control how many workers to use.",
            "title": "Experiment Classes"
        },
        {
            "location": "/#background",
            "text": "Triage is developed at the University of Chicago's  Center For Data Science and Public Policy . We created it in response to commonly occuring challenges we've encountered and patterns we've developed while working on projects for our partners.",
            "title": "Background"
        },
        {
            "location": "/#major-components-used-by-triage",
            "text": "Triage makes use of many core data science components developed at DSaPP. These components can be useful in their own right, and are worth checking out if    Architect : Plan, design and build train and test matrices. Includes feature and label generation.  Collate : Aggregation SQL Query Builder. This is used by the Architect to build features.  Timechop : Generate temporal cross-validation time windows for matrix creation  Metta-Data : Train and test matrix storage  Catwalk : Training, testing, and evaluating machine learning classifier models  Results Schema : Generate a database schema suitable for storing the results of modeling runs",
            "title": "Major Components Used by Triage"
        },
        {
            "location": "/#design-goals",
            "text": "There are two overarching design goals for Triage:    All configuration necessary to run the full experiment from the external interface (ie, Experiment subclasses) from beginning to end must be easily serializable and machine-constructable, to allow the eventual development of tools for users to design experiments.     All core functionality must be usable outside of a specific pipeline context or workflow manager. There are many good workflow managers; everybody has their favorite, and core functionality should not be designed to work with specific execution expectations.",
            "title": "Design Goals"
        },
        {
            "location": "/#future-plans",
            "text": "Generation and Management of lists (ie for inspections) by various criteria  Integration of components with various workflow managers, like  Drain  and  Luigi .  Comprehensive leakage testing of an experiment's modeling run  Feature Generation Wizard",
            "title": "Future Plans"
        },
        {
            "location": "/triage.experiments.base/",
            "text": "Source:\n \ntriage/experiments/base.py#L0\n\n\nGlobal Variables\n\n\n\n\nCONFIG_VERSION\n\n\n\n\n\n\ndt_from_str\n\n\ndt_from_str(dt_str)\n\n\n\n\n\n\nExperimentBase\n\n\nThe Base class for all Experiments.\n\n\nExperimentBase.all_as_of_times\n\n\nAll 'as of times' in experiment config\n\n\nUsed for label and feature generation.\n\n\nReturns: (list) of datetimes\n\n\nExperimentBase.all_label_windows\n\n\nAll train and test label windows\n\n\nReturns: (list) label windows, in string form as they appeared in the experiment config\n\n\nExperimentBase.collate_aggregations\n\n\ncollate Aggregation objects used by this experiment.\n\n\nReturns: (list) of collate.Aggregation objects\n\n\nExperimentBase.feature_dicts\n\n\nFeature dictionaries, representing the feature tables and columns configured in this experiment after computing feature groups.\n\n\nReturns: (list) of dicts, keys being feature table names and values being lists of feature names\n\n\nExperimentBase.feature_table_tasks\n\n\nAll feature table query tasks specified by this Experiment\n\n\nReturns: (dict) keys are group table names, values are themselves dicts, each with keys for different stages of table creation (prepare, inserts, finalize) and with values being lists of SQL commands\n\n\nExperimentBase.full_matrix_definitions\n\n\nFull matrix definitions\n\n\nReturns: (list) temporal and feature information for each matrix\n\n\nExperimentBase.master_feature_dictionary\n\n\nAll possible features found in the database. Not all features will necessarily end up in matrices\n\n\nReturns: (list) of dicts, keys being feature table names and values being lists of feature names\n\n\nExperimentBase.matrix_build_tasks\n\n\nTasks for all matrices that need to be built as a part of this Experiment.\n\n\nEach task contains arguments understood by Architect.build_matrix\n\n\nReturns: (list) of dicts\n\n\nExperimentBase.split_definitions\n\n\nTemporal splits based on the experiment's configuration\n\n\nReturns: (dict) temporal splits\n\n\nExample:\n\n\n{\n  'beginning_of_time': {datetime},\n  'modeling_start_time': {datetime},\n  'modeling_end_time': {datetime},\n  'train_matrix': {\n  'matrix_start_time': {datetime},\n  'matrix_end_time': {datetime},\n  'as_of_times': [list of {datetime}s]\n  },\n  'test_matrices': [list of matrix defs similar to train_matrix]\n}\n\n\n\n\n\n\nExperimentBase.\n__init__\n\n\n__init__(self, config, db_engine, model_storage_class=None, project_path=None, replace=True)\n\n\n\n\nInitialize self.  See help(type(self)) for accurate signature.\n\n\n\n\nExperimentBase.build_matrices\n\n\nbuild_matrices(self)\n\n\n\n\nGenerate labels, features, and matrices\n\n\n\n\nExperimentBase.catwalk\n\n\ncatwalk(self)\n\n\n\n\nTrain, test, and evaluate models\n\n\n\n\nExperimentBase.generate_labels\n\n\ngenerate_labels(self)\n\n\n\n\nGenerate labels based on experiment configuration\n\n\nResults are stored in the database, not returned\n\n\n\n\nExperimentBase.generate_sparse_states\n\n\ngenerate_sparse_states(self)\n\n\n\n\n\n\nExperimentBase.initialize_components\n\n\ninitialize_components(self)\n\n\n\n\n\n\nExperimentBase.initialize_factories\n\n\ninitialize_factories(self)\n\n\n\n\n\n\nExperimentBase.log_split\n\n\nlog_split(self, split_num, split)\n\n\n\n\n\n\nExperimentBase.matrix_store\n\n\nmatrix_store(self, matrix_uuid)\n\n\n\n\nConstruct a matrix store for a given matrix uuid, using the Experiment's #matrix_store_class\n\n\nArgs:\n\n\nmatrix_uuid (string) A uuid for a matrix\n\n\n\n\nExperimentBase.run\n\n\nrun(self)\n\n\n\n\n\n\nExperimentBase.update_split_definitions\n\n\nupdate_split_definitions(self, new_split_definitions)\n\n\n\n\nUpdate split definitions\n\n\nArgs: (dict) split definitions (should have matrix uuids)",
            "title": "ExperimentBase"
        },
        {
            "location": "/triage.experiments.base/#global-variables",
            "text": "CONFIG_VERSION",
            "title": "Global Variables"
        },
        {
            "location": "/triage.experiments.base/#dt_from_str",
            "text": "dt_from_str(dt_str)",
            "title": "dt_from_str"
        },
        {
            "location": "/triage.experiments.base/#experimentbase",
            "text": "The Base class for all Experiments.",
            "title": "ExperimentBase"
        },
        {
            "location": "/triage.experiments.base/#experimentbaseall_as_of_times",
            "text": "All 'as of times' in experiment config  Used for label and feature generation.  Returns: (list) of datetimes",
            "title": "ExperimentBase.all_as_of_times"
        },
        {
            "location": "/triage.experiments.base/#experimentbaseall_label_windows",
            "text": "All train and test label windows  Returns: (list) label windows, in string form as they appeared in the experiment config",
            "title": "ExperimentBase.all_label_windows"
        },
        {
            "location": "/triage.experiments.base/#experimentbasecollate_aggregations",
            "text": "collate Aggregation objects used by this experiment.  Returns: (list) of collate.Aggregation objects",
            "title": "ExperimentBase.collate_aggregations"
        },
        {
            "location": "/triage.experiments.base/#experimentbasefeature_dicts",
            "text": "Feature dictionaries, representing the feature tables and columns configured in this experiment after computing feature groups.  Returns: (list) of dicts, keys being feature table names and values being lists of feature names",
            "title": "ExperimentBase.feature_dicts"
        },
        {
            "location": "/triage.experiments.base/#experimentbasefeature_table_tasks",
            "text": "All feature table query tasks specified by this Experiment  Returns: (dict) keys are group table names, values are themselves dicts, each with keys for different stages of table creation (prepare, inserts, finalize) and with values being lists of SQL commands",
            "title": "ExperimentBase.feature_table_tasks"
        },
        {
            "location": "/triage.experiments.base/#experimentbasefull_matrix_definitions",
            "text": "Full matrix definitions  Returns: (list) temporal and feature information for each matrix",
            "title": "ExperimentBase.full_matrix_definitions"
        },
        {
            "location": "/triage.experiments.base/#experimentbasemaster_feature_dictionary",
            "text": "All possible features found in the database. Not all features will necessarily end up in matrices  Returns: (list) of dicts, keys being feature table names and values being lists of feature names",
            "title": "ExperimentBase.master_feature_dictionary"
        },
        {
            "location": "/triage.experiments.base/#experimentbasematrix_build_tasks",
            "text": "Tasks for all matrices that need to be built as a part of this Experiment.  Each task contains arguments understood by Architect.build_matrix  Returns: (list) of dicts",
            "title": "ExperimentBase.matrix_build_tasks"
        },
        {
            "location": "/triage.experiments.base/#experimentbasesplit_definitions",
            "text": "Temporal splits based on the experiment's configuration  Returns: (dict) temporal splits  Example:  {\n  'beginning_of_time': {datetime},\n  'modeling_start_time': {datetime},\n  'modeling_end_time': {datetime},\n  'train_matrix': {\n  'matrix_start_time': {datetime},\n  'matrix_end_time': {datetime},\n  'as_of_times': [list of {datetime}s]\n  },\n  'test_matrices': [list of matrix defs similar to train_matrix]\n}",
            "title": "ExperimentBase.split_definitions"
        },
        {
            "location": "/triage.experiments.base/#experimentbase__init__",
            "text": "__init__(self, config, db_engine, model_storage_class=None, project_path=None, replace=True)  Initialize self.  See help(type(self)) for accurate signature.",
            "title": "ExperimentBase.__init__"
        },
        {
            "location": "/triage.experiments.base/#experimentbasebuild_matrices",
            "text": "build_matrices(self)  Generate labels, features, and matrices",
            "title": "ExperimentBase.build_matrices"
        },
        {
            "location": "/triage.experiments.base/#experimentbasecatwalk",
            "text": "catwalk(self)  Train, test, and evaluate models",
            "title": "ExperimentBase.catwalk"
        },
        {
            "location": "/triage.experiments.base/#experimentbasegenerate_labels",
            "text": "generate_labels(self)  Generate labels based on experiment configuration  Results are stored in the database, not returned",
            "title": "ExperimentBase.generate_labels"
        },
        {
            "location": "/triage.experiments.base/#experimentbasegenerate_sparse_states",
            "text": "generate_sparse_states(self)",
            "title": "ExperimentBase.generate_sparse_states"
        },
        {
            "location": "/triage.experiments.base/#experimentbaseinitialize_components",
            "text": "initialize_components(self)",
            "title": "ExperimentBase.initialize_components"
        },
        {
            "location": "/triage.experiments.base/#experimentbaseinitialize_factories",
            "text": "initialize_factories(self)",
            "title": "ExperimentBase.initialize_factories"
        },
        {
            "location": "/triage.experiments.base/#experimentbaselog_split",
            "text": "log_split(self, split_num, split)",
            "title": "ExperimentBase.log_split"
        },
        {
            "location": "/triage.experiments.base/#experimentbasematrix_store",
            "text": "matrix_store(self, matrix_uuid)  Construct a matrix store for a given matrix uuid, using the Experiment's #matrix_store_class  Args:  matrix_uuid (string) A uuid for a matrix",
            "title": "ExperimentBase.matrix_store"
        },
        {
            "location": "/triage.experiments.base/#experimentbaserun",
            "text": "run(self)",
            "title": "ExperimentBase.run"
        },
        {
            "location": "/triage.experiments.base/#experimentbaseupdate_split_definitions",
            "text": "update_split_definitions(self, new_split_definitions)  Update split definitions  Args: (dict) split definitions (should have matrix uuids)",
            "title": "ExperimentBase.update_split_definitions"
        },
        {
            "location": "/triage.experiments.singlethreaded/",
            "text": "Source:\n \ntriage/experiments/singlethreaded.py#L0\n\n\n\n\nSingleThreadedExperiment\n\n\nThe Base class for all Experiments.\n\n\nSingleThreadedExperiment.all_as_of_times\n\n\nAll 'as of times' in experiment config\n\n\nUsed for label and feature generation.\n\n\nReturns: (list) of datetimes\n\n\nSingleThreadedExperiment.all_label_windows\n\n\nAll train and test label windows\n\n\nReturns: (list) label windows, in string form as they appeared in the experiment config\n\n\nSingleThreadedExperiment.collate_aggregations\n\n\ncollate Aggregation objects used by this experiment.\n\n\nReturns: (list) of collate.Aggregation objects\n\n\nSingleThreadedExperiment.feature_dicts\n\n\nFeature dictionaries, representing the feature tables and columns configured in this experiment after computing feature groups.\n\n\nReturns: (list) of dicts, keys being feature table names and values being lists of feature names\n\n\nSingleThreadedExperiment.feature_table_tasks\n\n\nAll feature table query tasks specified by this Experiment\n\n\nReturns: (dict) keys are group table names, values are themselves dicts, each with keys for different stages of table creation (prepare, inserts, finalize) and with values being lists of SQL commands\n\n\nSingleThreadedExperiment.full_matrix_definitions\n\n\nFull matrix definitions\n\n\nReturns: (list) temporal and feature information for each matrix\n\n\nSingleThreadedExperiment.master_feature_dictionary\n\n\nAll possible features found in the database. Not all features will necessarily end up in matrices\n\n\nReturns: (list) of dicts, keys being feature table names and values being lists of feature names\n\n\nSingleThreadedExperiment.matrix_build_tasks\n\n\nTasks for all matrices that need to be built as a part of this Experiment.\n\n\nEach task contains arguments understood by Architect.build_matrix\n\n\nReturns: (list) of dicts\n\n\nSingleThreadedExperiment.split_definitions\n\n\nTemporal splits based on the experiment's configuration\n\n\nReturns: (dict) temporal splits\n\n\nExample:\n\n\n{\n  'beginning_of_time': {datetime},\n  'modeling_start_time': {datetime},\n  'modeling_end_time': {datetime},\n  'train_matrix': {\n  'matrix_start_time': {datetime},\n  'matrix_end_time': {datetime},\n  'as_of_times': [list of {datetime}s]\n  },\n  'test_matrices': [list of matrix defs similar to train_matrix]\n}\n\n\n\n\n\n\nSingleThreadedExperiment.\n__init__\n\n\n__init__(self, config, db_engine, model_storage_class=None, project_path=None, replace=True)\n\n\n\n\nInitialize self.  See help(type(self)) for accurate signature.\n\n\n\n\nSingleThreadedExperiment.build_matrices\n\n\nbuild_matrices(self)\n\n\n\n\nGenerate labels, features, and matrices\n\n\n\n\nSingleThreadedExperiment.catwalk\n\n\ncatwalk(self)\n\n\n\n\nTrain, test, and evaluate models",
            "title": "SingleThreadedExperiment"
        },
        {
            "location": "/triage.experiments.singlethreaded/#singlethreadedexperiment",
            "text": "The Base class for all Experiments.",
            "title": "SingleThreadedExperiment"
        },
        {
            "location": "/triage.experiments.singlethreaded/#singlethreadedexperimentall_as_of_times",
            "text": "All 'as of times' in experiment config  Used for label and feature generation.  Returns: (list) of datetimes",
            "title": "SingleThreadedExperiment.all_as_of_times"
        },
        {
            "location": "/triage.experiments.singlethreaded/#singlethreadedexperimentall_label_windows",
            "text": "All train and test label windows  Returns: (list) label windows, in string form as they appeared in the experiment config",
            "title": "SingleThreadedExperiment.all_label_windows"
        },
        {
            "location": "/triage.experiments.singlethreaded/#singlethreadedexperimentcollate_aggregations",
            "text": "collate Aggregation objects used by this experiment.  Returns: (list) of collate.Aggregation objects",
            "title": "SingleThreadedExperiment.collate_aggregations"
        },
        {
            "location": "/triage.experiments.singlethreaded/#singlethreadedexperimentfeature_dicts",
            "text": "Feature dictionaries, representing the feature tables and columns configured in this experiment after computing feature groups.  Returns: (list) of dicts, keys being feature table names and values being lists of feature names",
            "title": "SingleThreadedExperiment.feature_dicts"
        },
        {
            "location": "/triage.experiments.singlethreaded/#singlethreadedexperimentfeature_table_tasks",
            "text": "All feature table query tasks specified by this Experiment  Returns: (dict) keys are group table names, values are themselves dicts, each with keys for different stages of table creation (prepare, inserts, finalize) and with values being lists of SQL commands",
            "title": "SingleThreadedExperiment.feature_table_tasks"
        },
        {
            "location": "/triage.experiments.singlethreaded/#singlethreadedexperimentfull_matrix_definitions",
            "text": "Full matrix definitions  Returns: (list) temporal and feature information for each matrix",
            "title": "SingleThreadedExperiment.full_matrix_definitions"
        },
        {
            "location": "/triage.experiments.singlethreaded/#singlethreadedexperimentmaster_feature_dictionary",
            "text": "All possible features found in the database. Not all features will necessarily end up in matrices  Returns: (list) of dicts, keys being feature table names and values being lists of feature names",
            "title": "SingleThreadedExperiment.master_feature_dictionary"
        },
        {
            "location": "/triage.experiments.singlethreaded/#singlethreadedexperimentmatrix_build_tasks",
            "text": "Tasks for all matrices that need to be built as a part of this Experiment.  Each task contains arguments understood by Architect.build_matrix  Returns: (list) of dicts",
            "title": "SingleThreadedExperiment.matrix_build_tasks"
        },
        {
            "location": "/triage.experiments.singlethreaded/#singlethreadedexperimentsplit_definitions",
            "text": "Temporal splits based on the experiment's configuration  Returns: (dict) temporal splits  Example:  {\n  'beginning_of_time': {datetime},\n  'modeling_start_time': {datetime},\n  'modeling_end_time': {datetime},\n  'train_matrix': {\n  'matrix_start_time': {datetime},\n  'matrix_end_time': {datetime},\n  'as_of_times': [list of {datetime}s]\n  },\n  'test_matrices': [list of matrix defs similar to train_matrix]\n}",
            "title": "SingleThreadedExperiment.split_definitions"
        },
        {
            "location": "/triage.experiments.singlethreaded/#singlethreadedexperiment__init__",
            "text": "__init__(self, config, db_engine, model_storage_class=None, project_path=None, replace=True)  Initialize self.  See help(type(self)) for accurate signature.",
            "title": "SingleThreadedExperiment.__init__"
        },
        {
            "location": "/triage.experiments.singlethreaded/#singlethreadedexperimentbuild_matrices",
            "text": "build_matrices(self)  Generate labels, features, and matrices",
            "title": "SingleThreadedExperiment.build_matrices"
        },
        {
            "location": "/triage.experiments.singlethreaded/#singlethreadedexperimentcatwalk",
            "text": "catwalk(self)  Train, test, and evaluate models",
            "title": "SingleThreadedExperiment.catwalk"
        },
        {
            "location": "/triage.experiments.multicore/",
            "text": "Source:\n \ntriage/experiments/multicore.py#L0\n\n\n\n\ninsert_into_table\n\n\ninsert_into_table(insert_statements, feature_generator_factory, db_connection_string)\n\n\n\n\n\n\nbuild_matrix\n\n\nbuild_matrix(build_tasks, planner_factory, db_connection_string)\n\n\n\n\n\n\ntrain_model\n\n\ntrain_model(train_tasks, trainer_factory, db_connection_string)\n\n\n\n\n\n\ntest_and_evaluate\n\n\ntest_and_evaluate(model_ids, predictor_factory, evaluator_factory, indiv_importance_factory, \\\n    test_store, db_connection_string, split_def, train_matrix_columns, config)\n\n\n\n\n\n\nMultiCoreExperiment\n\n\nThe Base class for all Experiments.\n\n\nMultiCoreExperiment.all_as_of_times\n\n\nAll 'as of times' in experiment config\n\n\nUsed for label and feature generation.\n\n\nReturns: (list) of datetimes\n\n\nMultiCoreExperiment.all_label_windows\n\n\nAll train and test label windows\n\n\nReturns: (list) label windows, in string form as they appeared in the experiment config\n\n\nMultiCoreExperiment.collate_aggregations\n\n\ncollate Aggregation objects used by this experiment.\n\n\nReturns: (list) of collate.Aggregation objects\n\n\nMultiCoreExperiment.feature_dicts\n\n\nFeature dictionaries, representing the feature tables and columns configured in this experiment after computing feature groups.\n\n\nReturns: (list) of dicts, keys being feature table names and values being lists of feature names\n\n\nMultiCoreExperiment.feature_table_tasks\n\n\nAll feature table query tasks specified by this Experiment\n\n\nReturns: (dict) keys are group table names, values are themselves dicts, each with keys for different stages of table creation (prepare, inserts, finalize) and with values being lists of SQL commands\n\n\nMultiCoreExperiment.full_matrix_definitions\n\n\nFull matrix definitions\n\n\nReturns: (list) temporal and feature information for each matrix\n\n\nMultiCoreExperiment.master_feature_dictionary\n\n\nAll possible features found in the database. Not all features will necessarily end up in matrices\n\n\nReturns: (list) of dicts, keys being feature table names and values being lists of feature names\n\n\nMultiCoreExperiment.matrix_build_tasks\n\n\nTasks for all matrices that need to be built as a part of this Experiment.\n\n\nEach task contains arguments understood by Architect.build_matrix\n\n\nReturns: (list) of dicts\n\n\nMultiCoreExperiment.split_definitions\n\n\nTemporal splits based on the experiment's configuration\n\n\nReturns: (dict) temporal splits\n\n\nExample:\n\n\n{\n  'beginning_of_time': {datetime},\n  'modeling_start_time': {datetime},\n  'modeling_end_time': {datetime},\n  'train_matrix': {\n  'matrix_start_time': {datetime},\n  'matrix_end_time': {datetime},\n  'as_of_times': [list of {datetime}s]\n  },\n  'test_matrices': [list of matrix defs similar to train_matrix]\n}\n\n\n\n\n\n\nMultiCoreExperiment.\n__init__\n\n\n__init__(self, n_processes=1, n_db_processes=1, *args, **kwargs)\n\n\n\n\nInitialize self.  See help(type(self)) for accurate signature.\n\n\n\n\nMultiCoreExperiment.build_matrices\n\n\nbuild_matrices(self)\n\n\n\n\nGenerate labels, features, and matrices\n\n\n\n\nMultiCoreExperiment.catwalk\n\n\ncatwalk(self)\n\n\n\n\nTrain, test, and evaluate models\n\n\n\n\nMultiCoreExperiment.parallelize\n\n\nparallelize(self, partially_bound_function, tasks, n_processes, chunksize=1)\n\n\n\n\n\n\nMultiCoreExperiment.parallelize_with_success_count\n\n\nparallelize_with_success_count(self, partially_bound_function, tasks, n_processes, chunksize=1)",
            "title": "MultiCoreExperiment"
        },
        {
            "location": "/triage.experiments.multicore/#insert_into_table",
            "text": "insert_into_table(insert_statements, feature_generator_factory, db_connection_string)",
            "title": "insert_into_table"
        },
        {
            "location": "/triage.experiments.multicore/#build_matrix",
            "text": "build_matrix(build_tasks, planner_factory, db_connection_string)",
            "title": "build_matrix"
        },
        {
            "location": "/triage.experiments.multicore/#train_model",
            "text": "train_model(train_tasks, trainer_factory, db_connection_string)",
            "title": "train_model"
        },
        {
            "location": "/triage.experiments.multicore/#test_and_evaluate",
            "text": "test_and_evaluate(model_ids, predictor_factory, evaluator_factory, indiv_importance_factory, \\\n    test_store, db_connection_string, split_def, train_matrix_columns, config)",
            "title": "test_and_evaluate"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperiment",
            "text": "The Base class for all Experiments.",
            "title": "MultiCoreExperiment"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperimentall_as_of_times",
            "text": "All 'as of times' in experiment config  Used for label and feature generation.  Returns: (list) of datetimes",
            "title": "MultiCoreExperiment.all_as_of_times"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperimentall_label_windows",
            "text": "All train and test label windows  Returns: (list) label windows, in string form as they appeared in the experiment config",
            "title": "MultiCoreExperiment.all_label_windows"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperimentcollate_aggregations",
            "text": "collate Aggregation objects used by this experiment.  Returns: (list) of collate.Aggregation objects",
            "title": "MultiCoreExperiment.collate_aggregations"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperimentfeature_dicts",
            "text": "Feature dictionaries, representing the feature tables and columns configured in this experiment after computing feature groups.  Returns: (list) of dicts, keys being feature table names and values being lists of feature names",
            "title": "MultiCoreExperiment.feature_dicts"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperimentfeature_table_tasks",
            "text": "All feature table query tasks specified by this Experiment  Returns: (dict) keys are group table names, values are themselves dicts, each with keys for different stages of table creation (prepare, inserts, finalize) and with values being lists of SQL commands",
            "title": "MultiCoreExperiment.feature_table_tasks"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperimentfull_matrix_definitions",
            "text": "Full matrix definitions  Returns: (list) temporal and feature information for each matrix",
            "title": "MultiCoreExperiment.full_matrix_definitions"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperimentmaster_feature_dictionary",
            "text": "All possible features found in the database. Not all features will necessarily end up in matrices  Returns: (list) of dicts, keys being feature table names and values being lists of feature names",
            "title": "MultiCoreExperiment.master_feature_dictionary"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperimentmatrix_build_tasks",
            "text": "Tasks for all matrices that need to be built as a part of this Experiment.  Each task contains arguments understood by Architect.build_matrix  Returns: (list) of dicts",
            "title": "MultiCoreExperiment.matrix_build_tasks"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperimentsplit_definitions",
            "text": "Temporal splits based on the experiment's configuration  Returns: (dict) temporal splits  Example:  {\n  'beginning_of_time': {datetime},\n  'modeling_start_time': {datetime},\n  'modeling_end_time': {datetime},\n  'train_matrix': {\n  'matrix_start_time': {datetime},\n  'matrix_end_time': {datetime},\n  'as_of_times': [list of {datetime}s]\n  },\n  'test_matrices': [list of matrix defs similar to train_matrix]\n}",
            "title": "MultiCoreExperiment.split_definitions"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperiment__init__",
            "text": "__init__(self, n_processes=1, n_db_processes=1, *args, **kwargs)  Initialize self.  See help(type(self)) for accurate signature.",
            "title": "MultiCoreExperiment.__init__"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperimentbuild_matrices",
            "text": "build_matrices(self)  Generate labels, features, and matrices",
            "title": "MultiCoreExperiment.build_matrices"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperimentcatwalk",
            "text": "catwalk(self)  Train, test, and evaluate models",
            "title": "MultiCoreExperiment.catwalk"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperimentparallelize",
            "text": "parallelize(self, partially_bound_function, tasks, n_processes, chunksize=1)",
            "title": "MultiCoreExperiment.parallelize"
        },
        {
            "location": "/triage.experiments.multicore/#multicoreexperimentparallelize_with_success_count",
            "text": "parallelize_with_success_count(self, partially_bound_function, tasks, n_processes, chunksize=1)",
            "title": "MultiCoreExperiment.parallelize_with_success_count"
        }
    ]
}